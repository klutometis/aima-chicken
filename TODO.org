* TODO Recursively sort the Australia tests.
* TODO Create neighbors from constraints when creating CSPs.
* TODO Abstract a =general-search=.
  See AIMA 3.7d. Might even create a search egg, if it's general
  enough.
* TODO =debug?= -> =aima-debug?=
* TODO Screencast on how to do a simple reflex agent.
* DONE Skip the animated gif!
  CLOSED: [2012-09-25 Tue 18:19]
  #+BEGIN_SRC sh
    mencoder "mf://@list" -mf fps=4 -o output.avi -ovc lavc -lavcopts vcodec=mpeg4
  #+END_SRC
* DONE Join tessellation-animations.
  CLOSED: [2012-09-25 Tue 18:19]
  See [[http://www.misterhowto.com/index.php?category%3DComputers&subcategory%3DVideo&article%3Djoin_with_mencoder][here]].
* DONE Search-strategy and distance for tessellation-solution as title
  CLOSED: [2012-09-24 Mon 08:09]
* DONE Test tessellation
  CLOSED: [2012-09-24 Mon 05:26]
  #+BEGIN_SRC scheme :tangle test-tessellation.scm :shebang #!/usr/bin/env chicken-scheme
    (use aima-tessellation debug)
    
    (let ((tessellation (tessellate)))
      (plot-tessellation tessellation
                         (vector (tessellation-start tessellation)
                                 (tessellation-end tessellation))
                         "harro.png"))
  #+END_SRC
* DONE Documentation!
  CLOSED: [2012-07-29 Sun 11:58]
  - CLOSING NOTE [2012-07-29 Sun 11:58] \\
    See [[http://wiki.call-cc.org/eggref/4/cock][cock]].
  How should we do this: roll our own with org/html/latex, or use the
  chicken wiki? Some eggs are merely pointers to the "real" docs.

  Would be nice to have something R-like: autodocs for the
  public-facing functions (some S-expression-based intermediate that
  goes to latex/html?); a hand-crafted vignette for HOWTO.

  If we use docstrings, we can coöpt the reader; do we have to deal
  specially with things like =case-lambda=, parameters, scalars and
  procedures (both of the =define= and naked lambda flavors)?

  Should we check out what [[http://docs.racket-lang.org/scribble/][scribble]] has to say? Is it time to
  resurrect [[http://www.cs.tufts.edu/~nr/noweb/][noweb]]?

  What about the language in the docstrings: latex, html, groff,
  markdown, docbook, restructured-text; any, all? Isn't it also
  uncomfortable to edit those sorts of things in strings without any
  editor support?

  Would it make sense, therefore, to have a documentation macro?

  Can the documentation itself be a Scheme structure along the lines
  of:

  #+BEGIN_SRC scheme :tangle doc.scm
    (use alist-lib
         debug
         define-record-and-printer
         lolevel
         matchable
         regex
         srfi-1
         srfi-13
         srfi-69
         stack)
    
    (import-for-syntax matchable)
    
    ;;; If we encounter a symbol, by the way, should give it back
    ;;; verbatim.
    (set-read-syntax! #\@ (lambda (in) (read in) (values)))
    
    @(title "Foo a bar in fixnum days.")
    @(author "Harro Freunds")
    @(email "harro@freunds.com")
    @(heading "The baz of quux")
    
    (define (foo bar #!optional baz #!rest quux)
      @("Foo a bar."
        "An optional and more thorough explanation involving fooing bars;
    what this really entails; pre- or post-conditions; &c."
        (bar "The bar to be foo'd")
        (baz "Some optional baz")
        (quux "The rest")
        ;; Can't have a parameter named `return', though; should use
        ;; `@return'; or `@<keyword>' in general for keywords?
        ;; `<keywords>:' such as: `return:', `rest:'. `markup: {latex,
        ;; html, groff, markdown, docbook}' is interesting.
        (@to "A foo'd bar"))
      bar)
    
    (define all-your-base
      @("Your base belong thither; don't fight it.")
      'belong-thither)
    
    (define (nullary-procedure)
      @("Nullary procedures take no parameters.")
      2 2 3 3)
    
    (define nullary-lambda
      @("Nullary procedures take no parameters.")
      (lambda () 2 2 3 3))
    
    (define current-docexpr
      @("Enables communication with the parsing @-reader")
      (make-parameter #f))
    
    (define-syntax syntax-test
      @("This is for reals."
        (some "parameter")
        (another "one")
        (@to "result"))
      (lambda (e r c)
        2))
    
    (define (with-new-doctable thunk)
      (parameterize ((current-doctable (make-hash-table)))
        (thunk)))
    
    ;;; Without an explicit return or description keyword (or other),
    ;;; can't distinguish the last description from the return value
    ;;; (which is optional, by the way).
    ;;;
    ;;; Some other structure for short and long descriptions: a list?
    (define test-case-lambda
      @("Just testing case-lambda"
        "We're mapping arbitrary arguments to arbitrary integers."
        (a "An argument")
        (b "Some other argument")
        (c "The rest arguments")
        (@to "An integer"))
      (case-lambda
       (() 2)
       ((a) 3)
       ((a b) 4)
       ((a b . c) 5)))
    
     (define-syntax debug
       @("Testing the syntax")
       (syntax-rules ()
         ((_ x ...)
          (with-output-to-port
              (current-error-port)
            (lambda ()
              (pp `((x ,x) ...)))))))
    
    (define docexprs (make-parameter (make-stack)))
    
    (define-record-and-printer null-expression)
    (define null-expression (make-null-expression))
    
    (set-read-syntax! #\@
      (lambda (in)
        (let ((expression (read in)))
          (if (symbol? expression)
              expression
              (begin
                (current-docexpr expression)
                (stack-push! (docexprs)
                             (make-docexpr (current-docexpr)
                                           null-expression))
                (values))))))
    
    (define-record-and-printer docexpr
      doc
      expr)
    
    (define parse-directive (make-parameter void))
    
    (define parse-procedure (make-parameter void))
    
    (define parse-scalar (make-parameter void))
    
    (define parse-parameter (make-parameter void))
    
    (define parse-case-lambda (make-parameter void))
    
    (define parse-syntax (make-parameter void))
    
    ;;; Somehow, we have to process these preamble-directives before we
    ;;; spit the document out; could it be that we have to keep the thing
    ;;; in memory before we spit it out?
    ;;;
    ;;; The document has some header fields and a list of docexprs: thus,
    ;;; we can process the docexprs in order, pushing to the section
    ;;; stack; &c.
    ;;;
    ;;; Should we say, more formally, that directives are things which
    ;;; work on the document; and have first-class support for things like
    ;;; sections?
    ;;;
    ;;; Sections, &c. could work, I suppose, by pushing something unto the
    ;;; docexprs stack.
    ;;;
    ;;; It's a shame, though, that the document-fields are fixed; and that
    ;;; directives don't have the ability to put arbitrary data in there.
    ;;; Why not add a hash-table called data?
    ;;;
    ;;; The idea is that the renderers check for some kind of field in the
    ;;; hash-table, supplying a reasonable default.
    ;;;
    ;;; It's a shame, though, that we have to special case so-called
    ;;; directives; can every parsed docexpr work on the document?
    ;;;
    ;;; Non-directive docexprs would have to push themselves on the
    ;;; docexpr-stack, though.
    ;;;
    ;;; Why not push every docexpr on the stack and convert the directives
    ;;; into no-ops? Bingo.
    ;;;
    ;;; docexprs are lambdas: at construction time, they take a document they
    ;;; can modify. At invocation time, they write something.
    ;;;
    ;;; If we were to support more than latex, though, how would they know
    ;;; to dispatch? Do we need an e.g. write-docexpr-as-{html,latex},
    ;;; such that we need to maintain the types?
    ;;;
    ;;; If I go with the dispatch-on-type, though, I have to come up with
    ;;; types for e.g. headings and subheading; which is a pain in the
    ;;; ass. Oh, for pure lambdas!
    (define-record-and-printer document
      data
      docexprs)
    
    (define (parse-docexpr document docexpr)
      (let ((doc (docexpr-doc docexpr))
            (expr (docexpr-expr docexpr))
            (data (document-data document)))
        (match expr
          ((? null-expression?)
           ((parse-directive) doc expr data document))
          (('define (procedure . formals) . body)
           ((parse-procedure) doc expr data procedure formals))
          (('define procedure ('lambda formals . body))
           ((parse-procedure) doc expr data procedure formals))
          (('define procedure ('case-lambda (formals . body) ...))
           ((parse-case-lambda) doc expr data procedure formals))
          (('define parameter ('make-parameter init . converter))
           ((parse-parameter) doc expr data parameter init))
          (('define scalar . body)
           ((parse-scalar) doc expr data scalar))
          (('define-syntax name . _)
           ((parse-syntax) doc expr data name))
          (_ 'unknown))))
    
    (define substitute-template
      (case-lambda
       ((template key substitution)
        (substitute-template template `((,key . ,substitution))))
       ((template substitutions)
        (string-substitute*
         template
         (map
          (match-lambda ((key . value)
                    (cons
                     (format "@~a@" (string-upcase (symbol->string key)))
                     (->string value))))
          substitutions)
         #f)))) 
    
    (define (write-template . keys-or-substitutions)
      (display (apply substitute-template keys-or-substitutions)))
    
    (define special-parameters '(@to))
    
    (define (special-parameter? parameter)
      (memq parameter special-parameters))
    
    (define normal-parameter? (complement special-parameter?))
    
    (define (doc-descriptions doc)
      (filter string? doc))
    
    (define (doc-normal-and-special-parameters doc)
      (let ((parameters (filter pair? doc)))
        (let ((normal-parameters
               (filter (compose normal-parameter? car) parameters))
              (special-parameters
               (filter (compose special-parameter? car) parameters)))
          (values normal-parameters special-parameters))))
    
    (define tex-preamble
      "\\documentclass{article}
    \\usepackage{fontspec}
    \\usepackage{amsmath}
    \\usepackage{tabularx}
    \\usepackage{minted}
    \\usemintedstyle{borland}
    \\usepackage[xetex,
      pdfborder=0 0 0,
      colorlinks,
      linkcolor=blue,
      citecolor=blue,
      urlcolor=blue]{hyperref}
    \\usepackage{caption}
    \\DeclareCaptionType{source}[Source][List of sources]
    \\renewenvironment{source}{}{}
    \\usepackage{capt-of}
    \\title{@TITLE@}
    \\author{@AUTHOR@
      \\texttt{<}\\href{mailto:@EMAIL@}
           {\\nolinkurl{@EMAIL@}}\\texttt{>}}
    \\begin{document}
    \\maketitle
    \\tableofcontents
    ")
    
    (define tex-footer
      "\\end{document}")
    
    (define tex-description
      "\\begin{description}
    @ITEMS@
    \\end{description}\n")
    
    (define tex-item-description
      "\\item[Description] @DESCRIPTION@")
    
    (define tex-arguments
      "\\emph{@ARGUMENTS@}")
    
    (define tex-procedure
      "\\item[Procedure] \\texttt{@NAME-AND-FORMALS@ $\\to$ @TO@}")
    
    (define tex-scalar
      "\\item[Scalar] \\texttt{@SCALAR@}")
    
    (define tex-parameter
      "\\texttt{@PARAMETER@} & @DEFINITION@")
    
    (define tex-parameter-object
      "\\item[Parameter] \\texttt{@PARAMETER@}")
    
    (define tex-syntax
      "\\item[Syntax] \\texttt{@NAME-AND-FORMALS@ $\\to$ @TO@}")
    
    (define tex-parameters
      "\\item[Parameters]
    \\begin{tabularx}{\\textwidth}[t]{lX}
    @PARAMETERS@
    \\end{tabularx}")
    
    (define tex-source
      "\\begin{source}
    \\begin{minted}[linenos]{scheme}
    @SOURCE@\\end{minted}
    \\label{@NAME@}
    \\end{source}
    ")
    
    (define tex-case-lambda-procedure
      "\\texttt{@NAME-AND-FORMALS@} & $\\to$ & \\texttt{@TO@}")
    
    (define tex-case-lambda
      "\\item[Procedure] 
    \\begin{tabular}[t]{lcl}
    @PROCEDURES@
    \\end{tabular}")
    
    (define tex-heading
      "\\section{@TITLE@}\n")
    
    (define tex-heading*
      "\\section*{@TITLE@}
    \\addcontentsline{toc}{section}{@TITLE@}\n")
    
    (define tex-subheading
      "\\subsection{@TITLE@}\n")
    
    (define tex-subheading*
      "\\subsection*{@TITLE@}
    \\addcontentsline{toc}{subsection}{@TITLE@}\n")
    
    (define tex-subsubheading
      "\\subsubsection{@TITLE@}\n")
    
    (define tex-subsubheading*
      "\\subsubsection*{@TITLE@}
    \\addcontentsline{toc}{subsubsection}{@TITLE@}\n")
    
    (define tex-substitutions
      '(
        ;; reverts to roman in texttt, etc.; see
        ;; <http://stackoverflow.com/questions/256457/how-does-one-insert-a-backslash-or-a-tilde-into-latex/257624#257624>
        ;; ("\\\\" . "\\textbackslash ")
        ("\\\\" . "\\char`\\\\ ")
        ("\\%" . "\\%")
        ("\\$" . "\\$")
        ("\\{" . "\\{")
        ("\\}" . "\\}")
        ("\\[" . "{[}")
        ("\\]" . "{]}")
        ("\\_" . "\\_")
        ("\\#" . "\\#")
        ("\\^" . "\\^")
        ;; ("\\_" . "{\\textunderscore}")
        ;; ("\n" . " ")
        ("\\~" . "\\~{}")
        ("\\&" . "\\&")
        ;; haven't tried this; is the analog to backslash above
        ;; ("\\~" . "\\char`\\~")
        ))
    
    (define (texify object)
      (string-substitute* (->string object) tex-substitutions #f))
    
    (define (tex-parse-directive doc expr data document)
      (let ((directive (car doc))
            (arguments (cdr doc))
            (data (document-data document)))
        (case directive
          ((email)
           (hash-table-set! data 'email (car arguments))
           void)
          ((author)
           (hash-table-set! data 'author (car arguments))
           void)
          ((title)
           (hash-table-set! data 'title (car arguments))
           void)
          ((heading)
           (lambda ()
             (hash-table-set! data 'heading-level 1)
             (write-template
              tex-heading
              `((title . ,(car arguments))))))
          ((subheading)
           (lambda ()
             (hash-table-set! data 'heading-level 2)
             (write-template
              tex-subheading
              `((title . ,(car arguments)))))))))
    
    (define (write-tex-block doc
                             expr
                             data
                             name
                             item
                             . rest-items)
      (let ((tex-heading
             (tex-make-heading
              (hash-table-ref/default
               data
               'heading-level
               0)))
            (description
             (tex-make-description (doc-descriptions doc))))
        (write-template
         tex-heading
         'title
         ;; (format "\\texttt{\\underline{~a}}" (texify name))
         (format "\\texttt{~a}" (texify name)))
        (write-template
         tex-description
         'items
         (string-join
          (cons item (cons description rest-items))
          "\n"))
        (write-template
         tex-source
         `((source .
            ,(with-output-to-string
               (lambda ()
                 (pp expr))))
           (name . ,name)))))
    
    (define (make-tex-procedure template name formals to)
      (substitute-template
       template
       `((name-and-formals . ,(texify (cons name formals)))
         (to . ,(string-join (map texify to) ", ")))))
    
    (define (make-tex-parameters parameters)
      (let ((parameters
             (map
              (match-lambda
                  ((parameter definition)
                   ;; Can we do a check here for stop-parameters
                   ;; like @return? Cleaner if we do it earlier.
                   (substitute-template
                    tex-parameter
                    `((parameter . ,(texify parameter))
                      (definition . ,(texify definition))))))
              parameters)))
        (if (null? parameters)
            ""
            (substitute-template
             tex-parameters
             'parameters
             ;; Already texified above.
             (string-join parameters "\\\\\n")))))
    
    (define (tex-procedure-to special-parameters)
      (alist-ref/default special-parameters '@to '("unspecified")))
    
    (define (tex-parse-procedure doc expr data name formals)
      (receive (normal-parameters special-parameters)
        (doc-normal-and-special-parameters doc)
        (let ((to (tex-procedure-to special-parameters)))
          (let ((procedure
                 (make-tex-procedure tex-procedure name formals to))
                (parameters (make-tex-parameters normal-parameters)))
            (lambda ()
              (write-tex-block
               doc
               expr
               data
               name
               procedure
               parameters))))))
    
    (define (tex-make-heading heading-level)
      (match heading-level
        (0 tex-heading)
        (1 tex-subheading)
        (2 tex-subsubheading)))
    
    (define (tex-make-description descriptions)
      (substitute-template
       tex-item-description
       'description
       (string-join (map texify descriptions) "\n\n")))
    
    (define (tex-parse-scalar doc expr data name)
      (let ((scalar
             (substitute-template
              tex-scalar
              'scalar
              (last expr))))
        (lambda ()
          (write-tex-block
           doc
           expr
           data
           name
           scalar))))
    
    (define (tex-parse-parameter doc expr data name init)
      (let ((parameter-object
             (substitute-template
              tex-parameter-object
              'parameter
              (texify init))))
        (lambda ()
          (write-tex-block
           doc
           expr
           data
           name
           parameter-object))))
    
    (define (tex-parse-case-lambda doc expr data name formals+)
      (receive (normal-parameters special-parameters)
        (doc-normal-and-special-parameters doc)
        (let ((to (tex-procedure-to special-parameters)))
          (let* ((procedures
                  (string-join
                   (map (lambda (formals)
                          (make-tex-procedure
                           tex-case-lambda-procedure
                           name
                           formals
                           to))
                        formals+)
                   "\\\\\n"))
                 (case-lambda
                  (substitute-template
                   tex-case-lambda
                   'procedures
                   procedures)))
            (let ((parameters (make-tex-parameters normal-parameters)))
              (lambda ()
                (write-tex-block
                 doc
                 expr
                 data
                 name
                 case-lambda
                 parameters)))))))
    
    (define (formals parameters) (map car parameters))
    
    (define (tex-parse-syntax doc expr data name)
      (receive (normal-parameters special-parameters)
        (doc-normal-and-special-parameters doc)
        (let ((to (tex-procedure-to special-parameters)))
          (let ((syntax
                 (make-tex-procedure
                  tex-syntax
                  name
                  (formals normal-parameters)
                  to))
                (parameters
                 (make-tex-parameters normal-parameters)))
            (lambda ()
              (write-tex-block
               doc
               expr
               data
               name
               syntax
               parameters))))))
    
    (define (tex-parse-docexpr document docexpr)
      (parameterize ((parse-directive tex-parse-directive)
                     (parse-procedure tex-parse-procedure)
                     (parse-case-lambda tex-parse-case-lambda)
                     (parse-parameter tex-parse-parameter)
                     (parse-scalar tex-parse-scalar)
                     (parse-syntax tex-parse-syntax))
        (parse-docexpr document docexpr)))
    
    (with-input-from-file "doc.scm"
      (lambda ()
        (let read-next ((expression (read)))
          (if (not (eof-object? expression))
              (begin
                (if (current-docexpr)
                    (docexpr-expr-set! (stack-peek (docexprs)) expression))
                (current-docexpr #f)
                (read-next (read)))))))
    
    (define (tex-parse-docexprs document docexprs)
      (let ((parsed-docexprs (make-stack)))
        (stack-for-each
         docexprs
         (lambda (docexpr)
           (stack-push! parsed-docexprs
                        (tex-parse-docexpr document docexpr))))
        parsed-docexprs))
    
    (let* ((document (make-document (make-hash-table) (make-stack)))
           (parsed-docexprs (tex-parse-docexprs document (docexprs))))
      (let ((data (document-data document)))
        (write-template
         tex-preamble
         `((author . ,(hash-table-ref/default data
                                              'author
                                              "Anonymous"))
           (email . ,(hash-table-ref/default data
                                             'email
                                             "anonymous@example.org"))
           (title . ,(hash-table-ref/default data
                                             'title
                                             "Documentation")))))
      (do ((docexpr (stack-pop! parsed-docexprs) (stack-pop! parsed-docexprs)))
          ((stack-empty? parsed-docexprs))
        (docexpr))
      (display tex-footer))
    
  #+END_SRC

  It would be nice to parse the signature from the definition; we're
  going to have to understand e.g. keywords, rest and optional
  parameters, then.

  Would be nice to have a link to the purged source, too (i.e. sans
  docs).

  If you load the module doc,

  See [[http://www.metapaper.net/lisovsky/ad/mole/][mole]] and [[http://wiki.call-cc.org/eggref/4/contracts][contracts]], by the way. The reader-macro should no-op on
  the docs when the code is compiled; there will be a separate reading
  step, I take it, when we generate the docs.

  Start with support for latex; generalize this later? Would be nice
  to generate wiki, too. I think we can even pre-post-order the
  doc-expr, can't we? Meh; let's just iterate over it: populating an
  e.g. hash-table.

  How is that reader going to work: iterates over top-level forms;
  recursively descending into it for an instance of a doc-expr? In
  which case: I wonder if we can have two packages, doc with a @-noop
  and doc-parser with a @-parser. The latter is called from the
  binary; the former is included in code.

  I wonder if each code block could operate on some hash-table
  parameter (e.g. =current-doc-table=), referenced by
  =set-read-syntax!=.

  That way, we don't have to identify @-exprs: we simply descend
  readingly and the read-syntax takes care of the rest. Say we wanted
  to use a doc-form (i.e. =(doc "Description" (foo "Bar") ...)=)
  instead; could we simply define a relevant doc-macro? We'd have to
  eval the contents, though, which I'd like to avoid.

  So we descend readingly, populate the doc-table for that expression;
  now what? Can we identify whether we're dealing with a scalar,
  parameter, procedure or case-lambda? In cases where this is obscured
  by e.g. a surrounding =let=, can we give a hint via =procedure:=,
  =scalar:=, =parameter:= hints? Also, do we special-case modules for
  the cats that don't separate module-definitions from
  implementations? Is there a way to figure out which forms are
  exported from a module and only include those, unless we have an
  =export:= hint?

  We'd have to have first-class support for modules, probably; would
  this also entail descending into =includes=? What about module-less
  code?

  That whole first-sentence as overview, second as detailed
  description thing is current; should we go with it?

  If we iterate through the doc-expr, why not a data-directed dispatch
  an e.g. string, symbol and pair; and thence a data-directed dispatch
  on =(car pair)=?

  Is there a latex package, by the way, for typesetting docs? Looks
  like we might be [[http://stackoverflow.com/questions/501241/can-latex-be-used-for-producing-any-documentation-that-accompanies-software][on our own]].

  For listings, try [[http://www.ctan.org/tex-archive/macros/latex/contrib/minted/][minted]]; maybe there can be a source section at the
  end of the document? Will this make sense without the unexported
  functions? Can we list the whole fucking thing and selectively
  hyper-ref in there? Let's try.

  Let's document top-level forms for now; becoming module-aware later.
  This decision has the side-effect that module-definitions will have
  to be separated from implementations. Maybe that's not a bad thing
  (cf. etags).

  On the other hand, Pygments is pretty garish; also, how are we going
  to link in without line-numbers or other? Hmm: =minted= provides
  =listing=; provided that we don't want to list the entire file.

  If we take Moritz Heidkamp's suggestion, incidentally, and use a
  =doc= macro instead of the =@= reader-macro . . . lost my thought.

  #+BEGIN_SRC tex :tangle doc.tex
    \documentclass{article}
    \usepackage{fontspec}
    \usepackage{amsmath}
    \usepackage{tabularx}
    \usepackage{minted}
    \usemintedstyle{borland}
    \usepackage[xetex,
      pdfborder=0 0 0,
      colorlinks,
      linkcolor=blue,
      citecolor=blue,
      urlcolor=blue]{hyperref}
    \usepackage{caption}
    \DeclareCaptionType{source}[Source][List of sources]
    \renewenvironment{source}{}{}
    \usepackage{capt-of}
    \title{Foo a bar in fixnum days.}
    \author{Harro Freunds
      \texttt{<}\href{mailto:harro@freunds.com}
           {\nolinkurl{harro@freunds.com}}\texttt{>}}
    \begin{document}
    \maketitle
    \tableofcontents
    \section{\texttt{bar}}
    \begin{description}
      \item[Scalar] \texttt{2}
      \item[Description] The number of Higgs bosons detected
    \end{description}
    \section{\texttt{foo}}
    \begin{description}
      \item[Procedure] \texttt{(foo \emph{bar \#!optional baz \#!rest quux}) $\to$ A foo'd bar}
      \item[Description] Foo a bar.
    
        An optional and more thorough explanation involving fooing bars;
        what this really entails; pre- or post-conditions; \&c.
      \item[Parameters]
        \begin{tabularx}{\textwidth}[t]{lX}
          \texttt{bar} & The bar to be foo'd \\
          \texttt{baz} & Some optional baz \\
          \texttt{quux} & The rest
        \end{tabularx}
    \end{description}
    \begin{source}
      \begin{minted}[linenos]{scheme}
    (define (foo bar #!optional baz #!rest quux)
      (if baz (baz quux))
      bar)
      \end{minted}
      \label{foo}
    \end{source}
    \section{\texttt{test-case-lambda}}
    \begin{description}
    \item[Procedure] 
      \begin{tabular}[t]{lcl}
          \texttt{(test-case-lambda)} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a})} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a b})} & $\to$ & \texttt{baz} \\
          \texttt{(test-case-lambda \emph{a b . c})} & $\to$ & \texttt{baz}
      \end{tabular}
    \item[Description] Test case-lambda.
    
      We're mapping arbitrary arguments to arbitrary integers: we have
      medadic, monadic, dyadic and polyadic formals.
    \item[Parameters]
      \begin{tabularx}{\linewidth}[t]{lX}
        a & An argument \\
        b & Some other argument \\
        c & The rest arguments
      \end{tabularx}
    \end{description}
    \begin{source}
    \begin{minted}[linenos]{scheme}
    (define test-case-lambda
      (case-lambda
       (() 2)
       ((a) 3)
       ((a b) 4)
       ((a b . c) 5)))
    \end{minted}
    \label{test-case-lambda}
    \end{source}
    \end{document}
    
  #+END_SRC

  Let's model the latex style after SRFIs; take [[http://srfi.schemers.org/srfi-1/srfi-1.html][SRFI-1]], for example:
  it has an abstract, rationale, &c. Can we just provide e.g. sections
  and arbitrary blocks of latex-formatted string? Sure. Or, how about
  =@(text ...)= blocks? How do we document such things in the
  self-same system? We can't!

  Do be able to do something like =cons* elt_1 elt_2 ...= or
  =make-list n [fill]= we're going to have to parse the parameter
  list; can we fake it, somehow? Also, there's a mapping to the type:
  =cons* elt_1 elt_2 ... -> object=.

  Should we formalize examples á la the following?

  #+BEGIN_EXAMPLE
    (cons 'a '())        => (a)
    (cons '(a) '(b c d)) => ((a) b c d)
    (cons "a" '(b c))    => ("a" b c)
    (cons 'a 3)          => (a . 3)
    (cons '(a b) 'c)     => ((a b) . c)
  #+END_EXAMPLE

  According to [[http://srfi.schemers.org/srfi-69/srfi-69.html][srfi-69]], =undefined= is the result of void; srfi-69
  also uses legitimate arrows. It also prefixes things with
  ``Procedure:''; can we do the same for parameters, macros, scalars?

  This is an interesting artifact:

  #+BEGIN_QUOTE
  Procedure: alist->hash-table alist [ equal? [ hash [ args … ]]] → hash-table
  #+END_QUOTE

  Procedure name is in roman; args are in italics; witness the nested
  brackets. Examples done over a math-array would be cool: aligned
  over the assignment operator.

  Others, like [[http://srfi.schemers.org/srfi-11/srfi-11.html][srfi-11]], specify procedures with angle-bracket-wrapped
  parameters:

  #+BEGIN_EXAMPLE
    (LET-VALUES ((<formals> <expression>) ...) <body>)
  #+END_EXAMPLE

  See [[http://srfi.schemers.org/srfi-13/srfi-13.html][srfi-13]]: yeah, let's go Olin Shivers style. Formal semantics,
  syntax, &c.? Not for now.

  #+BEGIN_SRC scheme
    (define (harro freunds)
      @("Say `harro' to freunds."
        (example (harro 'wirklich) "yes")
        (example (harro 'freunds) "jein")))
  #+END_SRC

  Special support for abstracts? See [[http://tex.stackexchange.com/questions/55922/name-a-section-in-latex-toc-add-subtitle-to-contentsline][subtitles in TOC]].

  Eventually, we want to pull all of the metadata out of =<egg>.meta=,
  or even populate the meta-file on the basis of e.g.
  =use=-statements. For now, though, we'll specify them with top-level
  forms.

  Damn: if we use the =listing= environment; we can have a
  =listoflistings=. Multipage listings are awkward, though: see [[http://tex.stackexchange.com/questions/12428/code-spanning-over-two-pages-with-minted-inside-listing-with-caption][this]],
  where they recommend using the =caption= package. Also [[http://tex.stackexchange.com/questions/7210/label-and-caption-without-float][this]], which
  is a more generic solution.
** TODO A record is similar to a procedure.
   Instead of parameters, however, it has fields; do we need to
   enumerate getters and setters? No, let them gather it from the
   source.
** DONE Syntax probably needs a signature in addition to parameters.
   CLOSED: [2012-07-28 Sat 13:51]
   Or can we infer the signature from the parameters? Or both?
** TODO Types from the Chicken wiki
   See [[https://wiki.call-cc.org/edit-help][here]]:
   
   - read
   - parameter
   - record
   - string
   - class
   - method
   - constant
   - setter
   - syntax
   - type

   Records are a really good idea; have to know: =defstruct=,
   =define-record=, =define-record-type=, &c. Which brings up
   something else: shouldn't we allow the user to override this?

   Some examples for [[http://wiki.call-cc.org/eggref/4/feature-test#acting-on-feature-support][read]], by the way; [[http://wiki.call-cc.org/eggref/4/lazy-ffi#read-syntax][more examples]]. Has to be
   invoked with [[http://wiki.call-cc.org/eggref/4/lazy-ffi#documentation][-X or -extension]] for compiled code.

   Christ, this complicates usage.
** TODO Should we try to evaluate the scalar?
   If it's self-evaluating, that's fine; otherwise, we have to load
   the module or file.
** TODO Support for version numbers in git repos.
   Take a look at the tags and descriptions.
** TODO First-class bibliography support.
   bibtex, &c.
** DONE Multiple values in =@to=
   CLOSED: [2012-07-25 Wed 15:04]
   Separate them by commas, or something?
** TODO Link to github or other source.
   God, it would be nice to be able to line-number into there.
** TODO =case-lambda=
   We might have to have separate =docexprs= for every arm of the
   case-lambda: ouch.

   Or can we simply have unified parameter-docs with optional
   defaults?

   Some support for default parameters; also, we're going to want to
   reference each form in the description, aren't we? Or does some
   notion of default parameter apply?
** TODO Syntax
   Expand the syntax, then parse it; along the way, figure out what
   the fuck it is when expanded.

   Even =expand*= doesn't help decipher it; might just have to list it
   as something opaque: or provide a =formals= parameter?

   R5RS calls it [[http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_idx_118][library syntax]]; let's use R5RS as the target: it has
   support for examples which align on \Rightarrow, &c.

   It also has e.g.:

   #+BEGIN_QUOTE
   _library-syntax_: =(or <test_1> ...)=
   #+END_QUOTE

   where =<test_1>= is in italics (but only sometimes).
** TODO Line-numbers
   Is [[http://wiki.call-cc.org/man/4/Unit%2520expand#get-line-number][get-line-number]] useful? Only for compiled code, though.
** TODO Examples
   Should we do it R-style, where we actually execute the blocks?
** TODO SRFI vs. R5RS style
   Let's go with R5RS; cool stuff, like syntax vs. semantics. Oh, wow:
   in the case of [[http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.2.6][quasiquotation]], they simply repeated the =syntax:=
   lines. We could also just use nested =[]=, but the formals for
   case-lambda need not be subsets of each other.
** TODO Forms that are unrecognizable.
   Macros, let-over-lambda; let's add some mechanism to override the
   parser.
** TODO =parse-docexprs= should be extensible.
** TODO Refer to other expressions in the same document with e.g. =\ref{foo}=.
** TODO Order them differently than they appear in the source code?
   Alphabetically, like R; or: according to conceptual groups
   (preferable)?
** TODO There's a disparity between what characters TeX and Scheme allow.
   This may bite us in things like labels; certainly, some escaping
   will have to take place.
* DONE Optional debugging environments.
  CLOSED: [2012-06-29 Fri 16:40]
  Can either have no-op environments that we graft in; or some other
  mechanism.

  Or, hell: instead of using the debug environments; why not have the
  classic debug-parameter that environments may or may not decide to
  use? That way, we'd have access to the agent's action as opposed to
  merely its state.
* DONE Debugging should really show what action the agent took and the state of the world.
  CLOSED: [2012-06-29 Fri 16:40]
  Not merely the e.g. agent location and score.

  What about a simple key-value debugger that produces uniform output?
* DONE Test vacuum world.
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme :tangle test-vacuum.scm :shebang #!/usr/local/bin/chicken-scheme
    (include "aima.scm")
    (include "aima-vacuum.scm")
    (use aima aima-vacuum)
    
    (simulate-vacuum (make-world dirty clean)
                     (make-reflex-agent
                      left
                      (lambda (location clean?)
                        'right))
                     10)
  #+END_SRC
* DONE debug-environment
  CLOSED: [2012-06-28 Thu 11:32]
  . . . with e.g. =environment-print=; it's just going to be a thunk
  unless it does something special. Because we're not doing OO, we
  can't readily have a generic print which dispatches à la e.g.
  =for-each= on worlds, agents, miscellaneous objects.

  What about =display=, though, with =define-record-printer=? Wow,
  maybe we should bring records back for environments; despite the
  fact that they're merely wrappers around a step-function.

  Environment is distinct from world, though; the debug function could
  have an optional display-function that defaults to =display=. That
  means, however, that we need a debug function per entity, doesn't
  it? Maybe that's no big deal.
* DONE Instead of aping the Lisp code, we should ship off on our own.
  CLOSED: [2012-06-28 Thu 11:32]
  Norvig did a wonderful thing, though: with this environment model
  and =run-environment=, he's able to cast e.g. search-problems as
  environments and run agents therein. A Chicken module might provide
  similar abstractions.
* DONE Environments
  CLOSED: [2012-06-03 Sun 03:47]
  - CLOSING NOTE [2012-06-03 Sun 03:47] \\
    This is reasonable as a proof-of-concept; we're going to imitate even
    the directory structure for now, though.
  We'll worry about utilities later; or, rather, along the way. It
  looks like [[http://wiki.call-cc.org/eggref/4/coops][coops]] is the way to go, incidentally:

  #+BEGIN_QUOTE
  05:03 < C-Keen> klutometis: coops is the new tinyclos
  #+END_QUOTE

  I toyed with the idea of getting rid of AIMA's OO; but, fuck it:
  we'll put it in. I'm aiming for a relatively shallow translation
  here; I don't necessarily want to redesign the thing.

  #+BEGIN_SRC scheme
    (use
     coops
     debug
     miscmacros
     )
    
    ;;; Environments
    
    (define-class <environment>
      (<standard-class>)
      ((agents
        initform: '()
        accessor: environment-agents)
       (step
        initform: 0
        accessor: environment-step)
       (max-steps
        initform: 1000
        accessor: environment-max-steps)
       (port
        initform: #t
        accessor: environment-port)
       (initialized?
        initform: #f
        accessor: environment-initialized?)
       (state
        initform: #f
        accessor: environment-state)))
    
    (define-class <agent>
      (<standard-class>)
      ((program
        initform: void
        accessor: agent-program)
       (body
        initform: (make-agent-body)
        accessor: agent-body)
       (score
        initform: 0
        accessor: agent-score)
       (percept
        initform: #f
        accessor: agent-percept)
       (action
        initform: #f
        accessor: agent-action)
       (name
        initform: #f
        accessor: agent-name)))
    
    (define (run-environment environment)
      (initialize environment)
      (display-environment environment)
      (call-with-current-continuation
       (lambda (return)
         (dotimes (i (environment-max-steps environment))
           (inc! (environment-step environment))
           (for-each (lambda (agent)
                       (set! (agent-percept agent)
                             (get-percept environment agent))
                       (set! (agent-action agent)
                             ;; TODO: `funcall' was here.
                             ((agent-program agent)
                              (agent-percept agent))))
             (environment-agents environment))
           (update-fn environment)
           (for-each (lambda (agent)
                       (set! (agent-score agent)
                             (performance-measure environment agent)))
             (environment-agents environment))
           (display-environment environment)
           (when (termination? environment) (return)))))
      environment)
    
    (define (agent-trials environment-fn agent-types #!key (n 10))
      (let ((env-gen-random-state (make-random-state #t)))
        (map (lambda (agent-type)
               (agent-trial environment-fn agent-type
                            (make-random-state env-gen-random-state) n)
               agent-types))))
    
    (define-method (get-percept (environment <environment>) agent) #f)
    
    (define-method (update-fn (env <environment>))
      "Modify the environment, based on agents actions, etc."
      (execute-agent-actions env))
    
    
    (define-method (legal-actions (env <environment>))
      "A list of the action operators that an agent can do."
      #f)
    
    (define-method (performance-measure (env <environment>) agent)
      "Return a number saying how well this agent is doing."
      (- (environment-step env)))
    
    ;;; Here are the ones that can usually be inherited:
    
    (define-method (initialize (env <environment>))
      "Called once to do whatever is necessary to set up the environment
      for running the simulation."
      (initialize-agent-names env)
      (set! (environment-initialized? env) t)
      env)
    
    (define-method (termination? (env <environment>))
      "Return true if the simulation should end now."
      #f)
    
    (define-method (display-environment (env <environment>))
      "Display the current state of the environment."
      ;; You probably won't need to specialize this, unless you want to do
      ;; a fancy graphical user interface
      (let ((port (environment-port env)))
        (when port 
          (format port "~&At Time step ~D:~%" (environment-step env))
          (when (> (environment-step env) 0)
                (for-each (lambda (port)
                            (format port 
                                    "~&Agent ~A perceives ~A~%~6Tand does ~A~%"
                                    agent (agent-percept agent)
                                    (agent-action agent)))
                  (environment-agents env)))
          (display-environment-snapshot env))))
    
    (define-method (display-environment-snapshot (env <environment>))
      "Display a 'picture' of the current state of the environment."
      (print env (environment-port env)))
    
    ;;;; Auxiliary Functions
    
    
  #+END_SRC
* DONE Do we really need e.g. =<stack>= instead of =stack= in =coops=?
  CLOSED: [2012-06-02 Sat 01:09]
  - CLOSING NOTE [2012-06-02 Sat 01:09] \\
    Yeah, to avoid namespace collisions with function arguments.
  #+BEGIN_SRC scheme
    (use coops
         test
         debug)
    
    (define-class <stack>
      ()
      ((data
        initform: '()
        accessor: stack-data)))
    
    (define-method (push (datum #t) (stack <stack>))
      (set! (stack-data stack)
            (cons datum (stack-data stack))))
    
    (test
     '(2 1)
     (let ((stack (make <stack>)))
       (push 1 stack)
       (push 2 stack)
       (stack-data stack)))
    
    (define (fuck-this-stack stack)
      (let ((new-stack (make <stack>)))
        (void)))
    
    (fuck-this-stack (make <stack>))
    
    (debug <stack>)
  #+END_SRC
* CANCELED Comparative animations of multiple paths
  CLOSED: [2012-09-25 Tue 18:19]
  - CLOSING NOTE [2012-09-25 Tue 18:19] \\
    We're doing serial animations with join-animations.
* CANCELED Allow specifying agent programs for graph agents.
  CLOSED: [2012-09-25 Tue 18:19]
* CANCELED Disguise hash-table operations in graph-world.
  CLOSED: [2012-09-25 Tue 18:19]
* CANCELED Need to distinguish betwee world and graph-world in vacuum.
  CLOSED: [2012-09-25 Tue 18:19]
* CANCELED =aima-vacuum= as a module that exposes =vacuum-two-square= and =vacuum-graph=
  CLOSED: [2012-09-25 Tue 18:19]
* CANCELED When agent return =#<undefined>=, there is an infinite loop.
  CLOSED: [2012-09-25 Tue 18:19]
* CANCELED One final debug output after last action.
  CLOSED: [2012-09-25 Tue 18:20]
* CANCELED sample-with-replacement
  CLOSED: [2012-06-28 Thu 11:32]
  #+BEGIN_SRC scheme
    (use
     debug
     (prefix random-bsd random-bsd:)
     srfi-1
     )
    
    (define (random-integer from to)
      "Return an integer chosen at random from the given interval."
      ;; Appears to be an off-by-one here:
      ;; (+ from (random-bsd:random-integer (+ 1 (- to from))))
      (+ from (random-bsd:random-integer (- to from))))
    
    (define (random-element list)
      "Return some element of the list, chosen at random."
      (list-ref list (random-integer 0 (length list))))
    
    (define (sample-with-replacement n population)
      (unfold (lambda (i)
                (debug (> i n))
                (> i n))
              (lambda (i)
                (debug (random-element population)
                       population)
                (random-element population))
              add1
              1))
    
    (sample-with-replacement 10 '(1 2 3))
  #+END_SRC
* CANCELED Try [[http://srfi.schemers.org/srfi-17/srfi-17.html][srfi-17]] for =defsetf=.
  CLOSED: [2012-06-28 Thu 11:32]
* CANCELED Beware, by the way: early bugs will be subtle.
  CLOSED: [2012-06-28 Thu 11:33]
* CANCELED Test environments.
  CLOSED: [2012-06-28 Thu 11:33]
  #+BEGIN_SRC scheme :tangle test-environments.scm :shebang #!/usr/bin/env chicken-scheme
    (include "aima.scm")
  #+END_SRC
